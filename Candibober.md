Структура кандибобера уже есть.

Предполагается (заглушка doCheck в модуле Candibober), что
HTTP-интерфейс (я его так и не сделал) будет принимать POST-запрос на
/check/targetname с телом вида:


    { "slot1" : { "model": "foo", "id": "2231"},
      "slot2" : { "model": "bar", "id": "69"}
    }

На этом этапе сервер должен запросить соответствующие модели с такими
id и подставить их вместо ключей, чтобы получилось:

    { "slot1" : { "k1": "v1", ...}
      "slot2" : { ...}
    }

Это и есть набор данных:

    type Dataset = M.Map SlotName Commit

Например, slot1 клиент может формировать как кейс, а slot2 — услугу,
которая проверяется.

Есть набор целей, к которым можно придти. Например, целью vw будем
считать набор условий для выполнения применимости программы VW.
Цели описаны в targets.js.

Condition, по которым проверяются наборы данных, состоит из названия и
проверялки.

Поскольку проверялки должны быть параметризуемые, в targets у
некоторых проверок есть "args". Смысл "args" зависит от проверки.
Типизации там никакой особой нет, хотя можно было бы сделать (чтобы не
писать числа в строках, например).

В args стоит либо одиночная строка, либо список строк. В зависимости
от этого args разбираются в тип CheckerArgs либо в Single, либо в
Many. Разбор происходит в (FromJSON Condition).

Эти аргументы используются для настройки проверялок (Checker).
Проверялка, которую ещё можно применить к CheckerArgs, имеет тип
FreeChecker:

    type FreeChecker m = CheckerArgs -> CheckBuilderMonad m Checker

Доступные проверялки объявлены в checkMap:

    checkMap :: M.Map B.ByteString (FreeChecker A.Parser)

Ключ здесь используется для выбора реализации по имени, указанному в
targets.json.

На пути от CheckerArgs до Checker может стоять несколько монадических
комбинаторов, живущих в монаде CheckBuilderMonad. Комбинаторы нужны,
чтобы как-то структурировать общную функциональность между разными, но
похожими проверками.

Как это выглядит снаружи:

    checkMap = M.fromList
        [ ("sellLess",
            compareDate "case" "car_sellDate" LT <=< yearsAgo <=< readInteger)
         , ("sellAfter",
            compareDate "case" "car_sellDate" GT <=< readDate)
         , ("checkupLess",
            compareDate "case" "car_checkupDate" LT <=< yearsAgo <=< readInteger)
         , ("mileageLess",
            compareNumber "case" "car_checkupMileage" LT <=< readInteger)
         , ("daysPassedSinceReport",
            compareDate "service" "car_checkupDate" GT <=< daysAgo <=< readInteger)
         , ("modelInList",
            fieldInList "case" "car_model" <=< readManyStrings)
         , ("ruamcEvac",
            fieldContains "case" "services" "towage" <<< readNone)
         , ("notVandal",
            fieldEquals "case" "notVandal" "1" <<< readNone)
         , ("notAccident",
            fieldEquals "case" "notAccident" "1" <<< readNone)
         , ("notUsedService",
            (inverseChecker . fieldContains "case" "services") <=< readSingleString)
         ]

(<=<) здесь работает примерно как (.), только монадически. Крайние
правые применяются к CheckerArgs и начинают процесс применения
параметров к проверялке, например (первый пункт checkMap):

    compareDate "case" "car_sellDate" LT <=< yearsAgo <=< readInteger

Сначала читаем число:

    readInteger :: Monad m => CheckerArgs -> CheckBuilderMonad m Integer

Потом берём и превращаем его в дату, равную текущей минус столько-то лет:

    yearsAgo :: Monad m => Integer -> CheckBuilderMonad m DateArg

Дальше подаём её в конец цепочки, где применены уже все аргументы,
кроме желанного DateArg:

    compareDate :: Monad m => SlotName -> FieldName -> Ordering -> DateArg
                -> CheckBuilderMonad m Checker

(этот комбинатор порождает проверялку, которая будет смотреть в
названное поле названного слота, читать его как дату и сравнивать с
датой, переданной в качестве аргумента; если две даты находятся в
нужном отношении, то проверка проходит)

FreeChecker живёт во время чтения targets.json и в конце цепочки
превращается уже в Checker.

    type Checker = Dataset -> Checking CheckResult

То есть он в монаде Checking выполняет какие-то действия над набором
данных и выдаёт CheckResult:

    type CheckResult = Maybe Bool    

тут Maybe для смысла «не удалось проверить», например если информации
в наборе данных недостаточно для принятия решения (возможно, нам это
не нужно).

Checking надо будет лазить в базу и к обращаться к серверу карт, поэтому:

    type Checking = IO

FreeChecker нужны для отлова ошибок в аргументах проверялок на этапе
чтения targets.json. CheckBuilderMonad это просто ErrorT. Каждый из
комбинаторов в цепочке (кроме тех, что выдают собственно чекеры),
может пораждать через throwError раннюю ошибку, которая отловится
сразу, а не когда уже будет срабатывать чекер. Клейзлева (>=>) работает
как обычная композиция, но в контексте обработки ошибок.

Для readNone, который просто смотрит, что аргументов проверке не
передано, понадобилась обёртка над (>=>), поскольку этот комбинатор
дальше по цепочке ничего не передаёт; различие как между (>>) и (>>=).

Собирая комбинаторы, можно реализовывать всякие проверки. Что-то можно
настроить в виде «типа проверки», что-то — вынести параметром в
targets.json. Интервалы можно делать парами проверок.
Проверять можно даты, числа (эти две проверять как бы с помощью compare)
и просто строки. Бинарные (неДТП) работают как сравнение со строкой "1"
(она и хранится в базе).

Из важных чекеров, которых нет: штука которая залезет сама в Redis
и проверит там существование ключа, обозначенного в таком-то поле
модели (нужно для vinCheck). Этот чекер тоже будет пользоваться тем
фактом, что чекеры работают в IO (как и проверялки на дату (им нужна
текущая дата)). «Программа действует» и «межсервисный интервал»
имхо можно собрать из имеющихся комбинаторов.

После проверки условий doCheck должен выдать JSON-ку с описанием
пройденных и непройденных проверок. Клиент её должен обработать и
использовать примерно там же, где сейчас стоит статический справочник
global.checks в функции renderChecks из local.js (она запускается,
когда меняется значение поля, у которого в meta прописано
targetCategory; выбирается значение этого поля и оно используется в
качестве названия цели, проверку рисуются под этим полем). Дифф к
коммиту r424 на эту тему как раз.

Возможно нужно избавиться от Single/Many в CheckerArgs и сразу
сделать инстансы FromJSON для DateArg и прочих чтобы избежать
лишнего этапа.
