(или «Как работает Редсон и Кандибобер»)

В данном примере мы рассмотрим основы нашего серверного слоя Redson, а также интерфейс Candibober.

# Redson

Рассмотрим *модели*, состоящие из именованного набора полей. Описания моделей даются в JSON-файлах в `resources/models`.
Модель с заполненными значениями полей и уникальным номером называем *экземпляром модели*.
Экземпляры моделей — просто наборы пар ключ-значение.

Для их хранения на стороне Redis используются хеши. [Redson](/f-me/snaplet-redson) предоставляет HTTP-CRUD-интерфейс к Redis,
используя JSON в качестве формата сериализации хешей. Методы CRUD ложатся на методы HTTP:

    CREATE — POST
    READ — GET
    UPDATE — PUT
    DELETE — DELETE

Содержимое экземпляра для методов C-U передаётся в теле запроса. Идентификатор экземпляра содержится в URL соответствующего метода.

В carma Redson установлен под путь `/_/`.
Доступ к операциями над моделью N выполняется с помощью запросов на `/_/N/<id>`.

Сперва в целях упрощения тестирования отключим проверку прав в Redson. В `snaplets/redson/snaplet.cfg`:

    transparent-mode = true

В этом режиме через Редсон можно хранить экземпляры любых моделей, даже неизвестных (то есть для которых нет описания в `models/`). Сохраним что-нибудь на сервер:

    $ curl localhost:8000/_/case/ -X POST -d '{"car_sellDate":"1297483647","car_model":"pocus"}'
    {"car_model":"pocus","id":"31","car_sellDate":"1297483647"}

ID для новых моделей генерируется на сервере автоматически и сообщается клиенту.
Прочитаем, что сохранили:

    $ curl localhost:8000/_/case/31
    {"car_model":"pocus","car_sellDate":"1297483647"}

Всё нормально.

# Candibober

Кандибобер позволяет проверять применимость предварительно заданных
условий к наборам экземпляров моделей. Именованная группа условий
называется *целью*. Цели описываются в файле `targets.json`.

Например, опишем следующую цель:

    {
        "vw": [
            {
                "type": "sellLess",
                "args": "2"
            },
            {
                "type": "modelInList",
                "args": ["focus", "pocus"]
            },
            {
                "type": "sellAfter",
                "args": "13.02.2011"
            },
            {
                "type": "notUsedService",
                "args": "hotel"
            }
        ]
    }

Она называется `vw` и содержит четыре условия. Семантика условий
описывается на стороне сервера в модуле `Snap.Snaplet.Candibober` в
`checkMap`. В целом каждое условие накладывает ограничение на
содержимое определённых полей проверяемых экземпляров. У условий есть
имена и аргументы, которые можно указать в JSON-файле целей для
гибкости.

Например, `notUsedService` требует, чтобы в поле `services` не
содержалось строки, указанной в `args`. `sellLess` требует, чтобы
дата в поле `car_sellDate` была не позднее двух лет от сегодняшнего
дня. Для `modelInList` нужно, чтобы в `car_model` содержалось одно из
указанных в `args` значений (в нашем случае, `focus` или `pocus`).

Кандибобер установлен под `/candibober/`. Единственный предоставляемый
им URL — `/candibober/check/<target_name>`.

Проверяемые экземпляры передаются клиентом кандибоберу не напрямую.
Считается, что все проверяемые данные уже есть в базе, поэтому по
имени модели и её ID Редсон может сам запросить их и передать в
Кандибобер. Поэтому формат тела запроса, отсылаемого в Кандибобер,
следующий:

    { "slot1" : { "model": "foo", "id": "2231"},
      "slot2" : { "model": "bar", "id": "69"}
    }

В каждом слоте указывается модель и код экземпляра, которые следует
поместить в этот слот.

После этого Кандибобер проверяет все условия из выбранной цели к на
получившемся наборе данных, возвращая три списка — выполненных
условий, невыполненных, и тех, что проверить не удалось.

    $ curl localhost:8000/candibober/check/vw/ -X POST -d '{"case":{"model":"case", "id":"31"}}'
    {"true":["modelInList","sellLess"],"nothing":["notUsedService"],"false":["sellAfter"]}

В качестве `car_model` мы ранее сохранили `pocus`, поэтому это условие
выполнилось. В `car_sellDate` мы сохранили `1297483647`, что
соответствует 12.02.2011. Проверка `sellLess` прошла, поскольку
сегодня (5.05.2012) ещё не прошло 2 года с указанной даты. Для условия
`sellAfter` мы потребовали дату продажи после 13.02.2011, поэтому эта
проверка не прошла. Информации об услугах (поля `services`) в
сохранённом экземпляре не было, поэтому с этим условием результат
определить не удалось.

Полученный от Кандибобера JSON можно обработать, чтобы изобразить
галочками пройденные/непройденные условия.
