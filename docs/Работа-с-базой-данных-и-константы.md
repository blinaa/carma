# baseline/patches

Для описания состояния БД и необходимых миграций используются директории database/{baseline, patches} и скрипт [db.sh](#dbsh).

# Приёмы разработки

Дамп базы можно взять с тестового сервера

После разворачивания дампа БД на локальной машине удобнее использовать шаблоны (чтобы не пересоздавать индексы):

    psql carma -c 'CREATE DATABASE carma_bak WITH TEMPLATE carma;'

Теперь, если база `carma` будет испорчена после плохо описанной миграции, её можно будет развернуть из шаблона `carma_bak`:

    dropdb carma
    psql carma_bak -c 'CREATE DATABASE carma WITH TEMPLATE carma_bak;'

# Idents

В случае, когда логика приложения зависит от конкретного значения поля в базе данных, например, марки автомобиля (допустим элемента с идентификатором 5 в справочнике `CarMake`), во избежание появления магических констант в коде необходимо сделать следующее:

1. Описать миграцию для БД, которая добавляет данное значение в базу (если его там ещё нет), а также обновить код справочника в baseline.
2. Записать это значение в модуль из пакета [carma-models](/ruamk/carma-models) с описанием соответствующей модели данных. Константы для модели `M` имеют тип `IdentI M`.

Создать константу можно двумя способами (в примерах описано создание констант для модели `CarMake`):

1. Явно описать отдельное значение:
   
   ```haskell
   peugeot :: IdentI CarMake
   peugeot = 12
   ```
2. Использовать Template Haskell-конструкцию `mkIdents`:
   
   ```haskell
   {-# LANGUAGE TemplateHaskell #-}
   import Data.Model.TH
   …
   mkIdents [t|CarMake|]
    [ ("vw", 1)
    , ("sy", 48)
    ]
   ```
Данный способ отличается от обычного тем, что помимо создания значений вида `vw = 1 :: IdentI CarMake`, он также задаёт отображение `idents :: HashMap.HashMap String (IdentI CarMake)`, которое позволяет из строки с названием константы получить её числовое значение. Эта возможность используется при проверке прав на экраны (т.к. screens.json использует текстовые названия ролей) и на клиенте.

Задание констант в модуле предполагает либо отсутствие списка экспортируемых идентификаторов в заголовке модуля:
```haskell
module Carma.Model.CarMake

where
…
```
либо явно перечисление всех заданных констант:
```haskell
module Carma.Model.CarMake (…, peugeot, citroen)

where
…
```

## Использование

### В серверном коде

После импорта модуля с заданными константами они используются как обычные значения:

```haskell
import qualified Carma.Model.CarMake as CarMake
…
    if cm == CarMake.peugeot
    …
```

### На клиенте

Заданные в методе `idents` (т.е. если для описания констант использовалась конструкция `mkIdents`) для модели `Model` константы доступны по строковым названиями через объект `global.idents("Model")`.

# db.sh

Из папки `carma/database` запускается команда
```
./db.sh update
```

Выполняется следующее:
* проверка коллизий (патчи с идентичными версиями)
* запуск всех ещё не наложенных патчей (т.е. те патчи из `patches/`, запись о которых отсутствует в таблице `version`), включая подключение пропущенных миграций

Версии baseline-данных, используемые в патчах соответствуют ревизии дерева, в которой последний раз изменялся соответствующий патч (исключая слияния!)

Дополнительное пояснение: когда будет накладываться конкретный патч из `database/patches` создастся временная директория `database`, которая будет переключена на коммит в котором последний раз правился накладываемый патч и файлы из `database/baseline` будут взяты оттуда (в состоянии соответствующего коммита).

## Приёмы слияния веток с миграциями
